"""
G-Code Generator Module
Generiert ISO 6983-1:2009 kompatible G-Code für CNC-Wickelmaschinen

Features:
- ISO 6983 Standard G-Code Ausgabe
- Unterstützung für verschiedene CNC-Controller (Fanuc, Siemens, etc.)
- Sichere Bewegungssequenzen
- Maschinenparameter-Optimierung
- Fehlerprüfung und Validierung
"""

from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
import re


@dataclass
class MachineConfig:
    """Maschinenparameter"""
    name: str
    max_speed_mm_min: float = 5000.0      # mm/min
    acceleration_mm_s2: float = 500.0     # mm/s²
    tool_diameter_mm: float = 2.0         # Fadendicke
    feed_rate_mm_min: float = 100.0       # Standard Vorschub
    controller_type: str = "fanuc"        # fanuc, siemens, heidenhain


@dataclass
class GCodeBlock:
    """Ein einzelner G-Code Befehl"""
    line_number: int
    gcode: str
    comment: str = ""
    
    def __str__(self) -> str:
        """Formatiere G-Code Block"""
        line = f"N{self.line_number} {self.gcode}"
        if self.comment:
            line += f" ; {self.comment}"
        return line


class GCodeGenerator:
    """Generiert ISO 6983 G-Code"""
    
    def __init__(self, machine_config: MachineConfig):
        self.config = machine_config
        self.blocks: List[GCodeBlock] = []
        self.line_number = 10
        self.current_position = (0.0, 0.0, 0.0, 0.0)  # X, Y, Z, Theta
        self.current_speed = machine_config.feed_rate_mm_min
    
    def reset(self):
        """Zurücksetzen des Generators"""
        self.blocks = []
        self.line_number = 10
        self.current_position = (0.0, 0.0, 0.0, 0.0)
        self.current_speed = self.config.feed_rate_mm_min
    
    def add_comment(self, comment: str):
        """Füge einen Kommentar hinzu"""
        block = GCodeBlock(
            line_number=self.line_number,
            gcode=f"; {comment}",
            comment=""
        )
        self.blocks.append(block)
        self.line_number += 10
    
    def add_block(self, gcode: str, comment: str = ""):
        """Füge einen G-Code Block hinzu"""
        block = GCodeBlock(
            line_number=self.line_number,
            gcode=gcode,
            comment=comment
        )
        self.blocks.append(block)
        self.line_number += 10
    
    def program_start(self, program_name: str = "WINDING"):
        """Starte ein neues G-Code Programm"""
        self.reset()
        
        # Header
        self.add_comment(f"Program: {program_name}")
        self.add_comment(f"Machine: {self.config.name}")
        self.add_comment("Auto-generated by FW Tool - Path Optimizer")
        self.add_block("%")  # Programm Start
    
    def program_end(self):
        """Beende das G-Code Programm"""
        self.add_block("M30")  # Program Ende
        self.add_block("%")    # Programm Ende Marker
    
    def setup_machine(self):
        """Richte Maschine ein"""
        self.add_comment("=== Machine Setup ===")
        self.add_block("G21", "Metric units (mm)")
        self.add_block("G90", "Absolute positioning")
        self.add_block("G40", "Cancel cutter compensation")
        self.add_block("G49", "Cancel tool offset")
        
        # Sicherheit
        self.add_block("M05", "Spindle Off")
        self.add_block("M09", "Coolant Off")
        
        # Schneller Positionierung zu Home
        self.add_block("G00 X0.0 Y0.0 Z0.0 A0.0", "Move to home position")
        self.current_position = (0.0, 0.0, 0.0, 0.0)
    
    def rapid_move(self, x: float, y: float, z: float, theta: float,
                   comment: str = "") -> bool:
        """
        Schnelle Positionierung (G00)
        
        Args:
            x, y, z: Cartesische Koordinaten (mm)
            theta: Rotationswinkel (°)
            comment: Kommentar
            
        Returns:
            True wenn erfolgreich
        """
        # Validiere Grenzen
        if not self._validate_position(x, y, z, theta):
            return False
        
        # Generiere G00 Block
        cmd = f"G00 X{x:.3f} Y{y:.3f} Z{z:.3f} A{theta:.1f}"
        self.add_block(cmd, comment if comment else "Rapid move")
        self.current_position = (x, y, z, theta)
        return True
    
    def linear_move(self, x: float, y: float, z: float, theta: float,
                   speed_mm_min: Optional[float] = None,
                   comment: str = "") -> bool:
        """
        Lineare Bewegung mit Vorschub (G01)
        
        Args:
            x, y, z: Cartesische Koordinaten (mm)
            theta: Rotationswinkel (°)
            speed_mm_min: Vorschubgeschwindigkeit (mm/min)
            comment: Kommentar
            
        Returns:
            True wenn erfolgreich
        """
        # Validiere Grenzen
        if not self._validate_position(x, y, z, theta):
            return False
        
        # Setze Vorschub falls angegeben
        if speed_mm_min and speed_mm_min != self.current_speed:
            self.add_block(f"F{speed_mm_min:.1f}", "Set feed rate")
            self.current_speed = speed_mm_min
        
        # Generiere G01 Block
        cmd = f"G01 X{x:.3f} Y{y:.3f} Z{z:.3f} A{theta:.1f}"
        self.add_block(cmd, comment if comment else "Linear move")
        self.current_position = (x, y, z, theta)
        return True
    
    def arc_move_xy(self, x: float, y: float, z: float, theta: float,
                   center_x: float, center_y: float,
                   clockwise: bool = True,
                   speed_mm_min: Optional[float] = None,
                   comment: str = "") -> bool:
        """
        Kreisbogen in XY-Ebene (G02/G03)
        
        Args:
            x, y, z: Endposition
            theta: Rotationswinkel
            center_x, center_y: Mittelpunkt des Bogens
            clockwise: True=G02 (CW), False=G03 (CCW)
            speed_mm_min: Vorschubgeschwindigkeit
            comment: Kommentar
            
        Returns:
            True wenn erfolgreich
        """
        if not self._validate_position(x, y, z, theta):
            return False
        
        if speed_mm_min and speed_mm_min != self.current_speed:
            self.add_block(f"F{speed_mm_min:.1f}")
            self.current_speed = speed_mm_min
        
        # Berechne Versätze (vom aktuellen Punkt zum Mittelpunkt)
        i = center_x - self.current_position[0]
        j = center_y - self.current_position[1]
        
        # Generiere G02/G03 Block
        gcode_cmd = "G02" if clockwise else "G03"
        cmd = f"{gcode_cmd} X{x:.3f} Y{y:.3f} Z{z:.3f} A{theta:.1f} I{i:.3f} J{j:.3f}"
        self.add_block(cmd, comment if comment else "Arc move")
        self.current_position = (x, y, z, theta)
        return True
    
    def dwell(self, time_seconds: float, comment: str = ""):
        """
        Verweilzeit (G04)
        
        Args:
            time_seconds: Verweilzeit in Sekunden
            comment: Kommentar
        """
        if time_seconds > 0:
            self.add_block(f"G04 P{time_seconds:.2f}", 
                          comment if comment else "Dwell")
    
    def tool_change(self, tool_number: int):
        """
        Werkzeugwechsel (M06)
        
        Args:
            tool_number: Werkzeugnummer
        """
        self.add_block(f"T{tool_number:02d} M06", f"Change to tool {tool_number}")
    
    def spindle_on(self, rpm: float, clockwise: bool = True):
        """
        Spindel einschalten (M03/M04)
        
        Args:
            rpm: Umdrehungen pro Minute
            clockwise: True=M03 (CW), False=M04 (CCW)
        """
        cmd = "M03" if clockwise else "M04"
        self.add_block(f"S{rpm:.0f} {cmd}", 
                      f"Spindle on {rpm} RPM")
    
    def spindle_off(self):
        """Spindel ausschalten (M05)"""
        self.add_block("M05", "Spindle off")
    
    def coolant_on(self, coolant_type: str = "flood"):
        """
        Kühlmittel einschalten
        
        Args:
            coolant_type: "flood" (M08) oder "mist" (M07)
        """
        cmd = "M08" if coolant_type == "flood" else "M07"
        self.add_block(cmd, f"Coolant on ({coolant_type})")
    
    def coolant_off(self):
        """Kühlmittel ausschalten (M09)"""
        self.add_block("M09", "Coolant off")
    
    def add_path_points(self, path_points: List[Dict],
                       z_safe_mm: float = 50.0,
                       use_rapid: bool = False,
                       feed_rate: Optional[float] = None):
        """
        Füge eine Reihe von Pfadpunkten hinzu
        
        Args:
            path_points: Liste von {"x", "y", "z", "theta", "speed"} Dicts
            z_safe_mm: Sichere Z-Höhe für schnelle Bewegungen
            use_rapid: Verwende schnelle Bewegungen (G00) statt linear (G01)
            feed_rate: Überschreibe Vorschub aus path_points
        """
        self.add_comment(f"=== Winding Path ({len(path_points)} points) ===")
        
        # Erste Bewegung ist immer schnelle Bewegung
        if path_points:
            first = path_points[0]
            # Schnelle Bewegung zu Z-sicherer Höhe
            self.rapid_move(first['x'], first['y'], z_safe_mm, 0.0,
                          "Move to safe height")
            # Schnelle Bewegung zu Startposition
            self.rapid_move(first['x'], first['y'], first['z'], first['theta'],
                          "Move to start of winding path")
        
        # Füge alle Pfadpunkte hinzu
        for i, point in enumerate(path_points):
            speed = feed_rate if feed_rate else point.get('speed', self.current_speed)
            
            if use_rapid:
                self.rapid_move(point['x'], point['y'], point['z'], 
                              point['theta'], f"Point {i+1}/{len(path_points)}")
            else:
                self.linear_move(point['x'], point['y'], point['z'],
                               point['theta'], speed,
                               f"Point {i+1}/{len(path_points)}")
    
    def add_return_to_safe(self, z_safe_mm: float = 50.0):
        """Fahre zu sicherer Position zurück"""
        self.add_comment("Return to safe position")
        self.rapid_move(0.0, 0.0, z_safe_mm, 0.0, "Move to Z-safe")
        self.rapid_move(0.0, 0.0, 0.0, 0.0, "Return to home")
    
    def _validate_position(self, x: float, y: float, z: float, 
                          theta: float) -> bool:
        """Validiere Position gegen Maschinengrenzwerte"""
        # Diese Grenzen können an spezifische Maschinen angepasst werden
        max_radius = 500.0  # mm
        max_z = 1000.0      # mm
        
        radius = (x**2 + y**2) ** 0.5
        
        if radius > max_radius:
            print(f"Warning: Radius {radius} exceeds max {max_radius}")
            return False
        if z < 0 or z > max_z:
            print(f"Warning: Z {z} out of range [0, {max_z}]")
            return False
        if theta < 0 or theta > 360:
            print(f"Warning: Theta {theta} out of range [0, 360]")
            return False
        
        return True
    
    def generate_code(self) -> str:
        """Generiere finalen G-Code String"""
        lines = [str(block) for block in self.blocks]
        return "\n".join(lines)
    
    def save_to_file(self, filename: str):
        """Speichere G-Code in Datei"""
        with open(filename, 'w') as f:
            f.write(self.generate_code())
        return filename
    
    def validate_code(self) -> List[str]:
        """Validiere den generierten Code"""
        warnings = []
        
        # Prüfe auf fehlende Sicherheitsbefehle
        code = self.generate_code()
        
        if "G00" not in code and "G01" not in code:
            warnings.append("No movement commands found")
        
        if "M05" not in code:
            warnings.append("Spindle never turned off")
        
        if "M30" not in code:
            warnings.append("Program end marker missing")
        
        return warnings


# Beispiel-Verwendung
if __name__ == "__main__":
    # Erstelle Maschinenconfig
    machine = MachineConfig(
        name="Filament Winding CNC 200",
        max_speed_mm_min=5000.0,
        acceleration_mm_s2=500.0,
        feed_rate_mm_min=100.0,
        controller_type="fanuc"
    )
    
    # Erstelle Generator
    gen = GCodeGenerator(machine)
    
    # Starte Programm
    gen.program_start("WINDING_TEST")
    gen.setup_machine()
    
    # Sichere Pfadpunkte hinzufügen
    sample_points = [
        {"x": 100.0, "y": 0.0, "z": 0.0, "theta": 0.0, "speed": 100.0},
        {"x": 100.0, "y": 0.0, "z": 10.0, "theta": 45.0, "speed": 100.0},
        {"x": 100.0, "y": 0.0, "z": 20.0, "theta": 90.0, "speed": 100.0},
    ]
    
    gen.add_path_points(sample_points, z_safe_mm=50.0)
    gen.add_return_to_safe()
    gen.program_end()
    
    # Ausgabe
    print(gen.generate_code())
